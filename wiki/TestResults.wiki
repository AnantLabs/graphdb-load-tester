#summary Results from tests so far

= GraphDB Results =
|| *Technology* || *Description* || *Results*||
|| *OrientDB* || The Orient DB database implementation suffered from very slow load times despite using the transactional API to batch operations. || The KVStore service can improve OrientDB performance but is still slow ||
|| *Neo4J* ||The Neo4J implementation uses the batch inserter API and the choice of higher performance indexing service discussed below to provide the Wikipedia-article-ID to Vertex-id lookup.||After 30 million additions the Neo4J database performance [https://spreadsheets.google.com/ccc?key=0AsKVSn5SGg_wdE5KWXFwd0JuRGlfR2NOMG5KVUVOWlE&hl=en&authkey=CLnptdAN hit a wall] and the load process had to be killed. [http://lists.neo4j.org/pipermail/user/2011-February/006969.html Subsequent conversations] have revealed that the memory required by Neo4J is directly proportional to the number of edges and at least 4 gig of RAM will be required to complete this particular test. I will tweak the config settings and repeat this test when I have access to appropriate hardware.||
|| *InfiniteGraph* || || This database will not be partaking in these tests at this time ||
|| *Lucene Graph* || Not strictly a graph database - using a Lucene document for each node and each edge with indexed properties for Article IDs || All 130 million records loaded into an 11GB index in 6 hours using < 1.5GB RAM with reasonably flat performance ||
|| *Index Only Graph + KVStore* || A "null" graph used to isolate indexing costs. Node ids are allocated for new nodes not in the index but edges and nodes are not stored|| All 130 million records read and indexed with Node ids in 45 minutes with flat performance (~2 seconds per batch of 100,000 edges= approx 0.02ms average node lookup cost in the KVStore) ||